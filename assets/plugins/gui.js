{info:{id:"BagelGUI",description:"A customisable plugin for creating GUIs in Bagel.js."},plugin:{scripts:{init:(e,t)=>{t.add.asset.snd({id:".BagelGUI.click",src:"data:audio/mpeg;base64,//OAxAAAAAAAAAAAAFhpbmcAAAAPAAAAAwAABBIAYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBg0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ////////////////////////////////////////////AAAAUExBTUUzLjk5cgRuAAAAAAAAAAA1CCQCzSEAAeAAAAQSSYAuqwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/zoMQAEnACyvdAAACoh3exu8jLeoIAgcKAgCAYLggCAIHCgIAhggGIPv5cEFg+D+sH/Lg4CHDHKHP/E4PghrBwMcEAQygY//BB3//+UBAEAx/KAhlAQcmYqIp0mTVUZDWGgyrJEUQYImG/BhWy0KoEQVVjZUyyAxi+zMxAcDuX+WiWnPTQwFZ4BkIgoSlO0HWRLRa6sZiyXtxgTnQ+IAlwFSpHstGDFzlpJ1J2pzS2mZiuluTRlbS2DUE23jTFgFMVrERfV4GUv7edHTZbTQ3CYA37KYccp4lAmlpzMpkEOspbRYs7LIi8j8MQbxBMzxd8NvvB7KbTgw4yl1W5P67sEQS7sYhl3Zx/ZbS7xUzi6X+TZJFYkkYszmT+NETCdJdz7uFIpTWyjsNSdyauojEpdBNNLm408Oz/87DE4loUgqsfmMAkgxuzs47j+VGWS1u8Uf913bjdZa8ehyAaaIu7EXJhhwZC4VK+0ifZr0F/j++Y/vHW6WVZwzAUWZ7FrTIbUonIxGL0OUt+9G5e5cXmm3gp+aBnEQfaROjKqF/Zl/ZQ+smaVSuk8zSmJNFZVG2Gv9BMO/dpccfkF6/er5y/LC67MYfWchq4/0fVrKAIu7lfHLva4zAQE2q//1VFBQEBKMzKuGAhVCgJqs+qAnVAVL/6vxmKMx///9VTqr/V9VXjMUZvgYCAQNP9YKrBX8S8ShsSgrEVZ0RBwRPg1Bp5U7rBUeGpUNiU78RBwRPUIoilTusFR4KqTEFNRTMuOTkuM6qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqv/zYMTZGtmybx/DGACqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqg=="}),t.add.asset.snd({id:".BagelGUI.clickUp",src:"data:audio/mpeg;base64,//OAxAAAAAAAAAAAAFhpbmcAAAAPAAAABAAABMkATk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnfn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn/////////////////////////////////AAAAUExBTUUzLjk5cgRuAAAAAAAAAAA1CCQDLCEAAeAAAATJpqKjmQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/zoMQAFogGux9BAAC6qruoVWtAv0iG8oCDgQcUBA4Jz8pLg+D+IAQd5cHwfB/rP/BAEDkoGPxACYPg+D5+GPUCAIA+/8HwQBAEAQBMH/h/8EAQBB3UCAPg+H/wQDH8HwfD8uD4Pg+qushml2hmlAYBrCAMEjTYbZgXKSJMQKAAkRyGgr9CoNCahLjLRnVAAhorQiAL13knoq8qAdYdH1rCt6FqmTC2dsHT1HCMoc2jWLUjdBRNoyJv4RMO0+0ZrvFNRFbrNnkWi/kVZar+lnZySwWwG4+ixJ1YkCQ+8pbp5BEMtK0x06WUrt+hjNymv+3B3YjhSwzfl+pU8dytnvDLdWPVbMpuUdPNWprdLVi9irfi0sqU17Ofj8Oyrct1AT9y2td13+c+7WpqbfJqlpatarGeX5Xf7rD/86DE0Up0bqMfmsAAw5zWN6btVKDKzU7yzzKbyps6amyrU1/uWWOOP8paa13k1DVLjTV7tumz7llnhjZyws6t1pfMyHcons7H42c6avS27mprVaNVbUzS/vdL3u/5l3+5fv7N/qaMNZRoSaM02g0LO2aTFcDsQUEAsfvVoGoStQqLLLRgFURCVLcDdYiz5huShkdWIiu/qVSyzERIxDHQ0pUtZNFTUECvRA6UymyVysMPMABBJfQHFAUZwC8TIEEyk3udBhrpMhGCRxJYZOULpBco1Sk7HGyX0/l6VsgUOZnGH2U2MI0A8GLUeKwWfCoQ8E0F/6BprcYalVlOdmj4tNyf6VXuLTLIuC/LorRbMhlMYw1BN2yzJs8dd2zGcZmTN3lUWlUzOQ3H4CpuPEw6G8qsZxtNxgFx//OwxNNQVC56/5jICGCqtSrclTdpucj0tjkRoKGIwTcd2njO6CtVptyqNXJuK0t2kpst61lv+a139Y6nN092prC19Ncls5QzfIlc3CL8BS+tasZXvm3RityJRaIxGw+0pj0Na7jvWWst/v//////UpprXcqYjJN1BQCkqkxBTUUzLjk5LjOqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqr/8xDE8QAAA/wBwAAAqqqqqqqqqqqqqqqqqg=="}),t.add.asset.snd({id:".BagelGUI.touch",src:"data:audio/mpeg;base64,//OAxAAAAAAAAAAAAFhpbmcAAAAPAAAABAAABP0ASkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlfn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn/////////////////////////////////AAAAUExBTUUzLjk5cgRuAAAAAAAAAAA1CCQDKiEAAeAAAAT9uAw0pwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/zoMQAEjkqnedDMACyMBL0ufxEQvkRC3REREKgYACCEe7JpkEIy7Jp3Ed7Jp3vezyad7+9nkyd7BMmH8uf8Tg+8uD4f/l///Ln/5d//h///rB9//g+z7q7iFlKYTSjQDSknrKLQgSoGlObS2JMhgJeYvuY7AQqCdmwWOKDMmn7BoHzfVVVDBTsLMmppKqLp0vOKCTvSCZkpdHXbYjEnpVuWSqo6TdY6z5ur2PA3FrEqV1EYgu8tyumPPoyarCXtXFGr8QhiZqr8pX8uxX4koFKn9eB8HDaw7rWJFKXioqVfzRW6vxFrMeu5RKAaDjxU8JmvtRDCV2s7eEsvZyCV49gGxGsaOrQvzT1XFsZczpYai2PYeyq3GyRSXSh3n8sSyN237rWKSKdhqLdhtiVC9kzIIlEpq69DRb/86DE406karb/mMAFHbtWq4NWxKsdSq9Wpq3JuxT27ff5X7T3+U+X2/yntXm4vk5WpFjMzsGWX6qVJdG5dlTRyHoL7Wz/Gl7rKm3KvrV8cfpr8Zw5vm+/vt/G9V5re6lXCtV5KptKs5xLtdN7LRLNNperiCirq5ChNOZN0QkNyLgShrjSgaOXwEQpl1LzMZFtXeJAWG2ugwCMCNzUA833wAgJFXiAwSlUnkYugAJmMGF1gGAPCykUA0eGnu4YEOjRSYWOGAildqzYmsuUy5iUvmJQAQcyg7MCIzJAUw00r8huy/cNv9U28b9Oy0iBBCHGPhRiiWYIThCaZeuGOoyQ7WYu15yXHdWd9Z6msOrSf+Mpywm2TF6mlNJAaDCEAQJmBCbMc6sImYkzqn5TydmE5FtTFmXQHCpN//PAxNRcDG6O/5nYDVKDH5bfR9WU0pr5ggqBA8oDTAQqCi/xcpSpqVz8LlBLOfbs5VZXujdmZpdX5qLSKjpb0upn9qw66lmtflMqp05X1a6/rouqyKIwwBQqKvq+Evp6ksmbcY7m78VoYzhVr5T7cG3l0W5dptdpH/ll+zVtWfx5LUJyri9r6yHdWgjThQG12U2M5TSRrGgXNn3///3/P////99pfGdgs1VMQU1FVUxBTUUzLjk5LjNVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//MQxPIAAAP8AcAAAFVVVVVVVVVVVVVVVVU="})}},types:{sprites:{GUI:{description:"Creates and manages a GUI.",args:{submenu:{required:!0,check:(e,t)=>{if(null==t.submenus[e])return"Oh no! That submenu doesn't seem to exist. Make sure it's added in the \"submenus\" argument."},types:["string"],description:"The id of the submenu to start in."},submenus:{required:!0,subcheck:{scroll:{required:!1,default:{},types:["object"],subcheck:{x:{required:!1,subcheck:{min:{required:!0,types:["number"],description:"The minimum camera x when scrolling. The left-most side of the submenu."},max:{required:!0,types:["number"],description:"The maximum camera x when scrolling. The right-most side of the submenu."}},types:["object"],description:"Options for scrolling horizontally."},y:{required:!1,subcheck:{min:{required:!0,types:["number"],description:"The minimum camera y when scrolling. The top of the submenu."},max:{required:!0,types:["number"],description:"The maximum camera y when scrolling. The bottom of the submenu."}},types:["object"],description:"Options for scrolling horizontally."}},description:"Scrolling options for this submenu."},init:{required:!1,types:["function"],description:"A function that runs when this submenu is switched to, after the animation has completed. It's called with the menuSprite and game objects."},main:{required:!1,types:["function"],description:"A function that runs when this submenu is active, after the animation has completed. Called with the menuSprite and game objects."},animationInit:{required:!1,types:["function"],description:"A function that runs as soon as this submenu is switched to, when the animation first starts. Called with the menuSprite, animationVars, submenuChangeAnimation and game."},animationMain:{required:!1,types:["function"],description:"A function that runs as soon as this submenu is active, when the animation is active. It's called with the menuSprite, animationVars, submenuChangeAnimation and game."}},types:["object"],arrayLike:!0,description:"The submenus in this menu. The key is the id and the value is an object."},elements:{required:!0,types:["array"],check:e=>{e.internal={dontClone:!0}},checkEach:!0,subcheck:{type:{required:!0,types:["string"],description:"The type of element."},submenu:{required:!0,types:["string"],description:"The id of the submenu that this element is in."},visible:{required:!1,default:!0,types:["boolean"],description:"If the element is visible or not."},fixedToCamera:{required:!1,default:!1,types:["boolean"],description:"If the element should be fixed to the camera or not. This will mean it won't move when the camera moves. It will reattatch temporarily for an animation though."},x:{required:!1,types:["number","string","function"],description:"The x position of the element."},y:{required:!1,types:["number","string","function"],description:"The y position of the element."},left:{required:!1,types:["number","function"],description:"The x position of the left side of the element."},top:{required:!1,types:["number","function"],description:"The y position of the top of the element."},right:{required:!1,types:["number","function"],description:"The x position of the right side of the element."},bottom:{required:!1,types:["number","function"],description:"The y position of the bottom of the element."},internal:{required:!1,types:["object"],description:"Stores some internal values."}},ignoreUseless:!0,arrayLike:!0,description:"The elements of your menu."},stateToActivate:{required:!0,types:["string"],description:"The game state that this submenu is active."}},cloneArgs:null,check:(e,t,i,n)=>{for(let t in e.elements){let i=e.elements[t].type;if(null==n.vars.types.elements[i])return"Huh, the type "+JSON.stringify(i)+" doesn't seem to exist. It has to be one of these:\n"+Object.keys(n.vars.types.elements).map(e=>" • "+JSON.stringify(e)+" -> "+n.vars.types.elements[e].description).join("\n")+"\nCheck you haven't mispelt it and that you added the GUIElement asset."}let r=e.internal;r.initialSubmenu=e.submenu,r.initialElements=Bagel.internal.deepClone(e.elements),r.plugin=n,((e,t)=>{e.internal.finishAnimation=(i=>{t.vars.finishAnimation(e,t)})})(e,n),e.scripts.main.push({code:(e,t)=>{let i=e.internal,n=i.plugin,r=!1;i.queuedSubmenuChangeAnimation&&(e.submenu=i.queuedSubmenuChangeAnimation[0],i.submenuChangeAnimation=i.queuedSubmenuChangeAnimation[1],i.queuedSubmenuChangeAnimation=null,r=!0),e.submenu!=e.internal.lastSubmenu&&(n.vars.initMenu(e,n),i.lastSubmenu=e.submenu);let a=i.submenuChangeAnimation;if(a){let n=e.internal.plugin.vars.types.animations[a.type].menuSprite.main;n&&n(e,a,i.animationVars,i.finishAnimation,t,e.vars.plugin);let s=e.submenus[e.submenu];r&&s.animationInit&&s.animationInit(e,i.animationVars,i.submenuChangeAnimation,t)}},stateToRun:e.stateToActivate});for(let r in e.elements){let a=e.elements[r],s=Bagel.internal.getTypeOf(a);if("object"!=s)return"Huh, sprite.elements item "+r+" is "+Bagel.internal.an(s)+"type. It should be an object.";let l=n.vars.types.elements[a.type],o="Game.game.sprites item "+e.idIndex+".elements item "+r;if(i({ob:a,where:o,syntax:{...l.args,...n.vars.checks.ignoreElement}}),null==e.submenus[a.submenu])return"Hmm, the submenu "+JSON.stringify(a.submenu)+' doesn\'t seem to exist. You might need to add it in the "submenus" argument.';if(l.check){let r=l.check(a,i,o,e,n,t);if(r)return r}}},init:(e,t,i)=>{e.internal.spriteElements=[],e.internal.previousSpriteElements=[],e.camera={x:0,y:0},e.internal.getFutureID=((e,t,i)=>n=>t(i,e,n))(t,i.vars.findID,e.id)},tick:e=>{let t=e.game,i=e.internal,n=e.submenus[e.submenu],r=n.scroll;r.x&&(1==Math.sign(t.input.scrollDelta.x)?e.camera.x<r.x.max&&(e.camera.x=Math.min(e.camera.x+t.input.scrollDelta.x,r.x.max)):e.camera.x>r.x.min&&(e.camera.x=Math.max(e.camera.x+t.input.scrollDelta.x,r.x.min))),r.y&&(1==Math.sign(t.input.scrollDelta.y)?e.camera.y<r.y.max&&(e.camera.y=Math.min(e.camera.y+t.input.scrollDelta.y,r.y.max)):e.camera.y>r.y.min&&(e.camera.y=Math.max(e.camera.y+t.input.scrollDelta.y,r.y.min))),Bagel.internal.current.pluginProxy=!0,i.submenuChangeAnimation?n.animationMain&&n.animationMain(e,i.animationVars,i.submenuChangeAnimation,t):n.main&&n.main(e,t)},listeners:{events:{delete:e=>{let t=e.internal;for(let e in t.spriteElements){let i=t.spriteElements[e];i&&i.delete()}}}}}}},methods:{sprite:{animateSubmenuChange:{fn:{fn:(e,t,i,n)=>{if(t.submenu==e.submenu)return;for(let e in t.optionalValues)null==t.animation[e]&&(t.animation[e]=t.optionalValues[e]);for(let e in t.defaultOverwrites){let i=t.defaultOverwrites[e];t.animation[i]=t.optionalValues[i]}let r=e.internal;r.queuedSubmenuChangeAnimation=[t.submenu,t.animation],r.animationVars={internal:{dontClone:!0}},e.internal.previousSpriteElements=[...e.internal.spriteElements]},args:{submenu:{required:!0,types:["string"],description:"The submenu to switch to."},animation:{required:!0,types:["object"],description:'The animation object. The arguments depend on the animation but the "type" argument is always required.'},optionalValues:{required:!1,default:{},types:["object"],description:"Allows required arguments to be made optional by using the value set here when unspecficied. For example, a button has a colour so a default can be set like this: menuSprite.animateSubmenuChange(..., ..., {color: element.color});"},defaultOverwrites:{required:!1,default:[],types:["array"],description:"The arguments that should be overwritten because they've defaulted to a value that isn't specific to this instance."}},obArg:!1,appliesTo:["GUI"]}}}},listeners:{prepState:(e,t,i)=>{for(let n in t.game.sprites){let r=t.game.sprites[n];if(r&&"GUI"==r.type){let t=r.internal;if(r.stateToActivate==e)t.initialized||(t.initialSubmenu=r.submenu,t.lastSubmenu=r.submenu,t.initialElements=Bagel.internal.deepClone(r.elements),i.vars.initMenu(r,i,!t.previouslyInitialized),t.previouslyInitialized=!0);else{r.elements=t.initialElements,r.submenu=t.initialSubmenu,t.initialized=!1;for(let e in t.spriteElements){let i=t.spriteElements[e];i&&i.delete()}t.spriteElements=[]}}}}}},vars:{initMenu:(e,t,n)=>{let r=e.internal,a=e.game;if(n){for(let i in e.elements){let e=r.initialElements[i],n=t.vars.types.elements[e.type];n.preload&&n.preload(e,a,t)}if(0!=a.internal.assets.loading)return}let s,l=r.submenuChangeAnimation,o=l?t.vars.types.animations[l.type]:{},q=r.spriteElements;if(l){let i=o;i.menuSprite.init&&(Bagel.internal.saveCurrent(),Bagel.internal.current.sprite=e,(s=i.menuSprite.init(e,l,r.animationVars,a,t,r.finishAnimation))&&(Array.isArray(s)||(s=[s])),Bagel.internal.loadCurrent())}for(let e in q)if(q[e]){let t=q[e].vars;t.old=!0,t.animationInitialized=!1,t.elementAnimationVars={}}for(i in e.elements){let n=Bagel.internal.deepClone(r.initialElements[i]),s=Bagel.internal.deepClone(r.initialElements[i]);if(n.submenu==e.submenu){let i=t.vars.types.elements[n.type],q="function"==typeof i.spriteDatas?i.spriteDatas(n,a,e.internal.getFutureID,e,t):i.spriteDatas;null==q?q=[]:Array.isArray(q)||(q=[q]);let m=e.internal.spriteElements,h=[];for(let i in q){let u=q[i];u.id=t.vars.findID(e.id,a),u.vars||(u.vars={}),u.vars.element=n,u.vars.originalElement=s,u.vars.spriteElementID=i,u.vars.animation=l,u.vars.animationVars=r.animationVars,u.vars.menuSprite=e,u.vars.plugin=t,u.vars.elementAnimationVars={},u.vars.linkedElements=h,u.vars.old=!1,u.visible=!1,o.hideNew&&(u.vars.element.visible=!1),u.scripts||(u.scripts={}),u.scripts.init||(u.scripts.init=[]),u.scripts.main||(u.scripts.main=[]),u.minProcess?(u.scripts.init.splice(0,0,{code:t.vars.process.element.minInit,stateToRun:a.state,affectVisible:!1}),u.scripts.main.splice(0,0,{code:t.vars.process.element.minMain,stateToRun:a.state})):(u.scripts.init.splice(0,0,{code:t.vars.process.element.init,stateToRun:a.state,affectVisible:!1}),u.scripts.main.splice(0,0,{code:t.vars.process.element.main,stateToRun:a.state}));let c=u.minProcess?0:1;for(;c<u.scripts.init.length;){let e=u.scripts.init[c];"object"==typeof e?(null==e.stateToRun&&(e.stateToRun=a.state),e.affectVisible=!1):"function"==typeof e&&(u.scripts.init[c]={code:e,stateToRun:a.state,affectVisible:!1}),c++}for(c=u.minProcess?0:1;c<u.scripts.main.length;){let e=u.scripts.main[c];"object"==typeof e?null==e.stateToRun&&(e.stateToRun=a.state):"function"==typeof e&&(u.scripts.main[c]={code:e,stateToRun:a.state}),c++}let d=["minProcess","deleteOnOtherDelete"];for(c in u.vars.tags={},d)u.hasOwnProperty(d[c])&&(u.vars.tags[d[c]]=u[d[c]],delete u[d[c]]);let p=a.add.sprite(u,"the plugin BagelGUI element type "+n.type+".spriteDatas item "+i),A=0;for(;A<m.length&&null!=m[A];)A++;m[A]=p,h.push(p)}}}for(let i in s){let n=s[i];n.id=t.vars.findID(e.id,a),n.vars||(n.vars={}),n.vars.menuSprite=e,n.vars.plugin=t,n.vars.animation=l,n.vars.animationVars=r.animationVars,n.vars.isAnimationSprite=!0,n.scripts||(n.scripts={}),n.scripts.init||(n.scripts.init=[]),n.scripts.init.splice(0,0,{code:t.vars.process.element.overrideDelete,stateToRun:a.state});let o=a.add.sprite(n,"the "+Bagel.internal.th(parseInt(i))+" sprite created by the "+JSON.stringify(l.type)+" animation in menuSprite.init"),m=0;for(;m<q.length&&null!=q[m];)m++;q[m]=o}e.camera.x=0,e.camera.y=0,r.initialized=!0},findID:(e,t,i=0)=>{let n=0;for(;;){let r=e+"#"+n;if(!t.get.sprite(r,!0)){if(0==i)return r;i--}n++}},finishAnimation:(e,t)=>{let i=e.internal,n=i.spriteElements,r=i.submenuChangeAnimation?t.vars.types.animations[i.submenuChangeAnimation.type]:{};i.submenuChangeAnimation=null;let a=i.previousSpriteElements;for(let e in a)a[e]&&(delete n[n.findIndex(t=>t&&t.id==a[e].id)],a[e].delete());for(let e in n)if(n[e]&&n[e].vars.isAnimationSprite)n[e].delete(),delete n[e];else{let t=n[e].vars.element,i=n[e].vars.originalElement;i.fixedToCamera&&(t.x=i.x,t.y=i.y,t.fixedToCamera=!0),r.hideNew&&(t.visible=i.visible)}i.previousSpriteElements=[],e.submenus[e.submenu].init&&(Bagel.internal.current.pluginProxy=!0,e.submenus[e.submenu].init(e,e.game))},process:{element:{overrideDelete:e=>{e.internal.delete=e.delete,(e=>{e.delete=(t=>{let i=e.vars.menuSprite,n=i.internal.spriteElements.findIndex(t=>t&&t.id==e.id);if(-1!=n&&delete i.internal.spriteElements[n],-1!=(n=i.internal.previousSpriteElements.findIndex(t=>t&&t.id==e.id))&&delete i.internal.previousSpriteElements[n],e.vars.linkedElements&&!e.vars.dontDeleteOthers)for(let t in e.vars.linkedElements)0!=t&&null!=e.vars.linkedElements[t]&&e.vars.linkedElements[t].vars.tags.deleteOnOtherDelete&&(e.vars.linkedElements[t].vars.dontDeleteOthers=!0,e.vars.linkedElements[t].delete());e.internal.delete()})})(e)},hideIfOffScreen:e=>{let t=e.vars.element.visible;e.x>game.width/2?e.left>game.width&&(t=!1):e.right<0&&(t=!1),e.y>game.height/2?e.top>game.height&&(t=!1):e.bottom<0&&(t=!1),e.visible=t},initElementPosition:e=>{if(0==e.vars.spriteElementID){null==e.width&&(e.width=e.game.width),null==e.height&&(e.height=e.game.height);let t=e.vars.element;t.hasOwnProperty("x")?e.x=t.x:t.hasOwnProperty("right")?e.right=t.right:t.hasOwnProperty("left")&&(e.left=t.left),t.hasOwnProperty("y")?e.y=t.y:t.hasOwnProperty("bottom")?e.bottom=t.bottom:t.hasOwnProperty("top")&&(e.top=t.top),t.x=e.x,t.y=e.y,e.vars.originalElement.x=e.x,e.vars.originalElement.y=e.y}},minInit:e=>{e.vars.plugin.vars.process.element.overrideDelete(e);e.vars.menuSprite;let t=e.vars.element;e.vars.plugin.vars.process.element.initElementPosition(e),t.fixedToCamera?(e.x=t.x,e.y=t.y):(e.x=t.x-e.vars.menuSprite.camera.x,e.y=t.y-e.vars.menuSprite.camera.y),e.vars.plugin.vars.process.element.hideIfOffScreen(e)},init:e=>{if(e.vars.plugin.vars.process.element.minInit(e),e.vars.animation){let t=e.vars.element;t.fixedToCamera=!1;let i=e.vars.plugin.vars.types.animations[e.vars.animation.type].elements.create;i&&i(t,e.vars.animation,e.vars.menuSprite,e.game,e.vars.plugin,e)}},minMain:e=>{let t=e.vars.menuSprite.internal.submenuChangeAnimation;e.vars.active=!t&&e.visible,e.vars.plugin.vars.process.element.hideIfOffScreen(e),e.vars.active&&e.layer.bringToFront()},main:e=>{let t=e.vars.element,i=e.vars.menuSprite.internal.submenuChangeAnimation;if(e.vars.active=!i&&e.visible,i){let n=e.vars.plugin.vars.types.animations[i.type].elements,r=e.vars.menuSprite.internal.submenuChangeAnimation;e.vars.animationInitialized||(e.vars.old&&t.fixedToCamera&&(t.x+=e.vars.menuSprite.camera.x,t.y+=e.vars.menuSprite.camera.y,t.fixedToCamera=!1),n.init&&n.init(t,r,e.vars.menuSprite.internal.animationVars,e.vars.menuSprite,e.game,e.vars.plugin,e),e.vars.animationInitialized=!0),n.main&&n.main(t,r,e.vars.menuSprite.internal.animationVars,e.vars.menuSprite.internal.finishAnimation,e.vars.menuSprite,e.game,e.vars.plugin,e)}i&&e.vars.old||(t.fixedToCamera?(e.x=t.x,e.y=t.y):(e.x=t.x-e.vars.menuSprite.camera.x,e.y=t.y-e.vars.menuSprite.camera.y),e.vars.plugin.vars.process.element.hideIfOffScreen(e)),e.vars.active&&e.layer.bringToFront()}}},types:{animations:{scroll:{elements:{create:(e,t,i,n,r,a)=>{let s;a.vars.animationVars.notEmpty=!0;let l=0,o=0;"left"==t.direction?(s=e.x,l=-n.width):"right"==t.direction?(s=e.x,l=n.width):"up"==t.direction?(s=e.y,o=-n.height):(s=e.y,o=n.height),t.stillCamera?t.scrollOld||(a.vars.elementAnimationVars.initialPosition=s,e.visible=!1,e.x-=l,e.y-=o):(e.x+=l,e.y+=o)},init:(e,t,i,n,r,a,s)=>{if(t.stillCamera&&s.vars.old==t.scrollOld){if(t.scrollOld){let i;i="left"==t.direction||"right"==t.direction?e.x:e.y,s.vars.elementAnimationVars.initialPosition=i}t.scrollOld?s.layer.bringToFront():e.visible=s.vars.originalElement.visible}},main:(e,t,i,n,r,a,s,l)=>{if(t.stillCamera&&l.vars.old==t.scrollOld){let n,r=l.vars.elementAnimationVars.initialPosition;"left"==t.direction||"right"==t.direction?(e.x+=i.vel,n=e.x-r):(e.y+=i.vel,n=e.y-r),t.scrollOld?"left"==t.direction?n<=-a.width&&(e.x=r-a.width,i.finished=!0):"right"==t.direction?n>=a.width&&(e.x=r+a.width,i.finished=!0):"up"==t.direction?n<=-a.height&&(e.y=r-a.height,i.finished=!0):"down"==t.direction&&n>=a.height&&(e.y=r+a.height,i.finished=!0):"left"==t.direction?n<=0&&(e.x=r,i.finished=!0):"right"==t.direction?n>=0&&(e.x=r,i.finished=!0):"up"==t.direction?n<=0&&(e.y=r,i.finished=!0):"down"==t.direction&&n>=0&&(e.y=r,i.finished=!0)}}},menuSprite:{init:(e,t,i)=>{t.stillCamera||("left"==t.direction||"right"==t.direction?i.initialCameraPosition=e.camera.x:i.initialCameraPosition=e.camera.y),"left"==t.direction||"up"==t.direction?i.vel=-5:i.vel=5},main:(e,t,i,n)=>{let r=e.game;if("left"==t.direction?i.vel-=r.width/125:"right"==t.direction?i.vel+=r.width/125:"up"==t.direction?i.vel-=r.height/125:i.vel+=r.height/125,t.stillCamera)!i.finished&&i.notEmpty||n();else{let a;"left"==t.direction||"right"==t.direction?(e.camera.x+=i.vel,a=e.camera.x-i.initialCameraPosition):(e.camera.y+=i.vel,a=e.camera.y-i.initialCameraPosition),"left"==t.direction?a<=-r.width&&(e.camera.x=i.initialCameraPosition-r.width,n()):"right"==t.direction?a>=r.width&&(e.camera.x=i.initialCameraPosition+r.width,n()):"up"==t.direction?a<=-r.height&&(e.camera.y=i.initialCameraPosition-r.height,n()):"down"==t.direction&&a>=r.height&&(e.camera.y=i.initialCameraPosition+r.height,n())}i.vel*=.9}},args:{direction:{required:!1,default:"right",types:["string"],check:e=>{if(!["left","right","up","down"].includes(e))return'Oh no! This must be either "left", "right", "up" or "down".'},description:'The direction for either the camera to scroll (so the elements scroll the opposite way). Or either the old or new elements (depends on "scrollOld") to scroll (if "stillCamera" is true). Either "left", "right", "up" or "down".'},stillCamera:{required:!1,default:!1,types:["boolean"],description:"If the camera shouldn't move and either the new or old elements should move instead or not. If set to true and \"scrollOld\" set to false, you'll want a new background to cover up the old elements."},scrollOld:{required:!1,default:!1,types:["boolean"],description:'Only applies when "stillCamera" is true. Determines if the old or new elements should move.'}},description:"Either the camera, new elements or old elements scroll in one of four directions to reveal the elements in another submenu."},triangleScroll:{elements:{main:(e,t,i,n,r,a,s,l)=>{i.covered&&!i.coveredDone&&(l.vars.old?l.delete():(e.visible=l.vars.originalElement.visible,l.layer.bringToFront()))}},menuSprite:{init:(e,t,i,n,r,a)=>{let s=t.direction;return"left"==s||"right"==s?(i.triangleWidth=n.height/2,i.triangleHeight=n.height):(i.triangleWidth=n.width/2,i.triangleHeight=n.width),{type:"canvas",fullRes:!0,width:i.triangleWidth,height:i.triangleHeight,mode:"static",vars:{dir:s,vel:0,finish:a},clones:{prerender:(e,t,i,n)=>{if(i.fillStyle="black",0==e.cloneID){let n=e.vars.dir;"left"==n||"right"==n?(e.width=1.25*t.width,e.height=t.height):(e.width=t.width,e.height=1.25*t.height),i.fillRect(0,0,1,1)}else i.clearRect(0,0,n.width,n.height),i.beginPath(),i.moveTo(0,0),i.lineTo(n.width,0),i.lineTo(n.width,n.height/2),i.lineTo(0,0),i.fill(),i.beginPath(),i.moveTo(0,n.height),i.lineTo(n.width,n.height),i.lineTo(n.width,n.height/2),i.lineTo(0,n.height),i.fill(),e.vars.otherClone=t.get.sprite(e.parent.cloneIDs[0])},scripts:{main:[(e,t)=>{e.layer.bringToFront();let i=e.vars.dir;"left"==i?(0==e.cloneID?e.left=e.parent.right:e.left=e.vars.otherClone.right,e.right<0&&1==e.cloneID&&(e.parent.vars.done=!0)):"right"==i?(0==e.cloneID?e.right=e.parent.left:e.right=e.vars.otherClone.left,e.left>t.width&&1==e.cloneID&&(e.parent.vars.done=!0)):"up"==i?(0==e.cloneID?e.top=e.parent.y+e.parent.width/2:e.y=e.vars.otherClone.bottom+e.width/2,e.bottom<0&&1==e.cloneID&&(e.parent.vars.done=!0)):(0==e.cloneID?e.bottom=e.parent.y-e.parent.width/2:e.y=e.vars.otherClone.top-e.width/2,e.top>t.height&&1==e.cloneID&&(e.parent.vars.done=!0))}]}},scripts:{init:[{code:(e,t)=>{let i=e.vars.dir;"left"==i?(e.angle=-90,e.left=t.width):"right"==i?e.right=0:"up"==i?(e.angle=0,e.y=t.height+e.width/2):(e.y=-e.width/2,e.angle=180),e.clone({width:1,height:1,angle:90,fullRes:!1,updateRes:!1}),e.clone()},stateToRun:n.state}],main:[{code:e=>{let t=e.vars,i=t.dir;"left"==i||"up"==i?t.vel-=5:t.vel+=5,"left"==i||"right"==i?(e.x+=t.vel,"left"==i?e.right<0&&(e.vars.animationVars.covered=!0):e.left>n.width&&(e.vars.animationVars.covered=!0)):(e.y+=t.vel,"up"==i?e.bottom<0&&(e.vars.animationVars.covered=!0):e.top>n.height&&(e.vars.animationVars.covered=!0)),t.vel*=.9,e.vars.done&&e.vars.finish()},stateToRun:n.state}]},prerender:(e,t,i,n)=>{i.clearRect(0,0,n.width,n.height),i.fillStyle="black",i.beginPath(),i.moveTo(0,0),i.lineTo(0,n.height),i.lineTo(n.width,n.height/2),i.lineTo(0,0),i.fill()}}},main:(e,t,i)=>{i.covered&&(i.waited?i.coveredDone=!0:i.waited=!0)}},args:{direction:{required:!1,default:"right",types:["string"],check:e=>{if(!["left","right","up","down"].includes(e))return'Oh no! This must be either "left", "right", "up" or "down".'},description:'The direction for the triangle to move. Either "left", "right", "up" or "down".'}},hideNew:!0,description:"A fairly simple animation where a triangle covers up the screen before another triangle erases it and reveals the new submenu."},circle:{elements:{create:(e,t,i,n,r,a)=>{a.vars.animationVars.notEmpty=!0,a.vars.elementAnimationVars.initialPosition=e.y,e.y+=n.height},main:(e,t,i,n,r,a,s,l)=>{if(!l.vars.old&&i.circleDone){e.visible=l.vars.originalElement.visible;let t=l.vars.elementAnimationVars.initialPosition;e.y+=i.vel,e.y-t<=0&&(e.y=t,i.finished=!0)}}},menuSprite:{init:(e,t,i)=>{let n=e.game;return t.x-=e.camera.x,t.y-=e.camera.y,i.vel=-3,{type:"canvas",mode:"static",x:t.x,y:t.y,vars:{vel:2,burstTick:0,doneTick:0},prerender:(e,t,i,n)=>{if(0==e.vars.doneTick){i.fillStyle=e.vars.animation.color,i.beginPath();let t=n.width/2;i.arc(t,t,t,0,2*Math.PI),i.fill(),e.updateRes=!1,e.width=e.vars.animation.initialSize,e.height=e.width}else i.fillStyle=e.vars.animation.color,i.fillRect(0,0,1,1),e.updateRes=!1,e.width=t.width,e.height=t.height,e.x=t.width/2,e.y=t.height/2},scripts:{main:[{code:(e,t)=>{if(0==e.vars.doneTick){e.vars.burstTick++,15==e.vars.burstTick?e.vars.vel+=50:e.vars.vel++,e.width+=e.vars.vel,e.height=e.width;let i=Math.floor(Math.sqrt(2*Math.pow(e.width,2))/2);e.x-i/2<=0&&e.x+i/2>=t.width&&e.y-i/2<=0&&e.y+i/2>=t.height&&(e.vars.doneTick=1,e.width=1,e.height=1,e.updateRes=!0,e.fullRes=!1)}else 15==e.vars.doneTick?e.vars.animationVars.circleDone=!0:e.vars.doneTick++},stateToRun:n.state}]},width:.8*Math.max(n.width,n.height),height:.8*Math.max(n.width,n.height)}},main:(e,t,i,n)=>{i.finished||i.circleDone&&!i.notEmpty?n():i.circleDone&&(i.vel-=game.height/200)}},args:{x:{required:!0,types:["number"],description:"The x position of the circle."},y:{required:!0,types:["number"],description:"The y position of the circle."},color:{required:!0,types:["string"],description:'The colour of the circle, any HTML colour. e.g "rgb(100, 50, 20)" or "#FF00FF".'},initialSize:{required:!1,default:1,types:["number"],description:"The diameter of the circle when the animation starts."}},hideNew:!0,description:"A circle grows to fill the screen and the new elements slide on from the bottom."}},elements:{button:{args:{color:{required:!0,types:["string"],description:'The colour of the button, any HTML colour. e.g "rgb(100, 50, 20)" or "#FF00FF".'},size:{required:!0,types:["number"],description:"The height/diameter of the button. The width can be more than the height if the icon is wide."},icon:{required:!1,types:["string"],description:"The ID of the image asset to use as an icon."},onclick:{required:!1,types:["object","function"],subcheck:{submenu:{required:!0,types:["string"],description:"The submenu to switch to when it's clicked."},animation:{required:!1,default:{},types:["object"],description:"The animation to use for the transition."}},description:"The action to happen when it's clicked. Set to an object with the \"submenu\" property set to the new submenu ID to change submenus. Set to a function to run code when it's clicked."},shape:{required:!1,default:"circle",types:["string"],check:e=>{if(!["circle","square","hardSquare"].includes(e))return"Hmm, "+JSON.stringify(e)+' isn\'t an option. It has to be either "circle", "square" or "hardSquare".'},description:'The shape of the button. Either "circle", "square" or "hardSquare". Button widths and heights might not match when using long icons but these still use the same shape names.'}},preload:(e,t)=>{e.icon&&t.get.asset.img(e.icon)},check:(e,t,i,n,r,a)=>{if("object"==typeof e.onclick){let n=e.onclick.animation;null==n.type&&(n.type="scroll");let a=r.vars.types.animations[n.type];if(null==a){let e=Object.keys(r.vars.types.animations);return"Oh no! The animation "+JSON.stringify(n.type)+" doesn't seem to exist. It can only be one of these:\n"+e.reduce((t,i,n)=>t+"  • "+JSON.stringify(i)+" -> "+r.vars.types.animations[i].description+(n==e.length-1?"":"\n"),"")}let s={...r.vars.checks.animation,...a.args},l=["x","y","color","initialSize","size"];e.internal={setDefaults:[]};for(let t in l){let i=l[t];s[i]&&(n.hasOwnProperty(i)||(s[i].required?s[i].required=!1:e.internal.setDefaults.push(i)))}t({ob:e.onclick.animation,where:i,syntax:s})}},spriteDatas:(e,t,i)=>{const n=[];return n.push({type:"canvas",scripts:{steps:{mouseUp:(e,t)=>{let i=e.vars.element;if(!t.input.mouse.down&&e.vars.clicked&&(!e.vars.clickLock||e.width==i.size)&&(t.playSound(".BagelGUI.clickUp"),e.vars.clicked=!1,e.vars.clickResetting=!0,e.vars.clickLock=!1,e.vars.vel+=.05,"object"==typeof i.onclick)){let t=i.onclick;e.vars.menuSprite.animateSubmenuChange(t.submenu,t.animation,{x:i.x,y:i.y,initialSize:i.size,size:i.size,color:i.color},e.vars.element.internal.setDefaults)}},mouseDown:(e,t)=>{e.vars.vel-=.1,e.vars.clicked||(t.playSound(".BagelGUI.click"),e.vars.clicked=!0,e.width<e.vars.maxSize?e.vars.vel+=3:e.vars.vel-=.3,e.vars.clickResetting=!1,"function"==typeof e.vars.element.onclick?e.vars.element.onclick(e.vars.element,e,e.vars.menuSprite):e.vars.clickLock=!0)},mouseTouch:(e,t)=>{e.vars.vel+=.1,e.vars.touched||(t.playSound(".BagelGUI.touch"),e.vars.touched=!0)}},init:[e=>{e.clone()}],main:[(e,t,i)=>{let n=e.width;e.vars.active&&(i("mouseUp"),e.touching.mouseCircles()||e.vars.clickLock?t.input.mouse.down||e.vars.clickLock?i("mouseDown"):i("mouseTouch"):(e.vars.touched=!1,e.vars.vel-=.09,e.width==e.vars.element.size&&(e.vars.clickResetting=!1))),n+=e.vars.vel,e.vars.vel*=.9,n>e.vars.maxSize&&(n=e.vars.maxSize,e.vars.vel=0),e.vars.touched||n<e.vars.element.size&&(n=e.vars.element.size,e.vars.vel=0),n<e.vars.minSize&&(n=e.vars.minSize,e.vars.vel=0),e.width=n,e.height=n}]},width:e.size,height:e.size,fullRes:!0,vars:{maxSize:1.05*e.size,minSize:e.size,vel:0,touched:!1,clicked:!1,clickResetting:!1,clickLock:!1},mode:"static",prerender:(e,t,i,n)=>{e.updateRes=!0;let r=e.width;e.width=e.vars.maxSize,e.height=e.width,e.updateRes=!1,e.width=r,e.height=r;let a=e.vars.element;i.fillStyle=a.color,i.clearRect(0,0,n.width,n.height),i.beginPath(),i.arc(n.width/2,n.height/2,n.width/2,0,2*Math.PI),i.fill()},clones:{scripts:{main:[e=>{e.x=e.parent.x,e.y=e.parent.y;let t=(e.parent.width-e.vars.element.size)/(e.vars.maxSize-e.vars.element.size);e.width=t*e.vars.maxSize,e.height=e.width,e.alpha=.05*t,0==e.width||e.parent.vars.clickResetting?e.visible=!1:e.visible=!0}]},prerender:(e,t,i,n)=>{e.updateRes=!0;let r=e.width;e.width=e.vars.maxSize,e.height=e.width,e.updateRes=!1,e.width=r,e.height=r,i.fillStyle="black",i.beginPath(),i.arc(n.width/2,n.height/2,n.width/2,0,2*Math.PI),i.fill()}}}),e.icon&&n.push({img:e.icon,vars:{parent:i(0)},scripts:{init:[e=>{e.vars.parent=e.game.get.sprite(e.vars.parent)}],main:[e=>{e.x=e.vars.parent.x,e.y=e.vars.parent.y,e.width=.85*e.vars.parent.width,e.height=e.width,e.visible=e.vars.parent.visible}]},minProcess:!0,deleteOnOtherDelete:!0}),n},description:"A simple button that can trigger a submenu change or code to run."},text:{args:Bagel.internal.plugin.plugin.types.sprites.text.args,spriteDatas:(e,t)=>{let i=Bagel.internal.plugin.plugin.types.sprites.text.args,n={};for(let t in i)e.hasOwnProperty(t)&&(n[t]=e[t]);return{type:"text",...n}},description:"Some simple text. Has an almost idential syntax to the sprite type."},image:{args:{...Bagel.internal.plugin.plugin.types.sprites.sprite.args,color:{required:!1,types:["string"],description:'The colour to use instead of an image, any HTML colour. e.g "rgb(100, 50, 20)" or "#FF00FF".'}},preload:(e,t)=>{e.color||t.get.asset.img(e.img)},spriteDatas:(e,t)=>{let i=Bagel.internal.plugin.plugin.types.sprites.sprite.args,n={};for(let t in i)e.hasOwnProperty(t)&&(n[t]=e[t]);if(e.color){let i=".BagelGUI.color."+e.color;if(!Bagel.internal.render.texture.get(i,t)){let n=document.createElement("canvas");n.width=1,n.height=1;let r=n.getContext("2d");r.fillStyle=e.color,r.fillRect(0,0,1,1),Bagel.internal.render.texture.new(i,n,t,!1,"static")}n.img=i}return{type:"sprite",...n}},description:'Almost idential in syntax to the "sprite" sprite type, but you can set the "color" argument to an HTML colour instead of using an image if you want.'}}},checks:{ignoreElement:{type:"ignore",submenu:"ignore",visible:"ignore",fixedToCamera:"ignore",x:"ignore",y:"ignore",left:"ignore",top:"ignore",right:"ignore",bottom:"ignore",internal:"ignore"},animation:{type:{required:!1,default:"scroll",types:["string"],description:"The name of the animation to use."}}}}}
